/**************************************************************************************************************
 *
 * MODULE: MC2
 *
 * FILE NAME: main2.c
 *
 * Description: main file for the micro controller 2
 *
 * Created on: November 6, 2022
 *
 * Author: Saeed Elsayed
 *
 **************************************************************************************************************/

#include "uart.h"
#include "twi.h"
#include <util/delay.h>
#include "DC_motor.h"
#include <avr/io.h>
#include "external_eeprom.h"
#include "timer1.h"
#include "gpio.h"
#include "buzzer.h"


uint8 volatile end_of_callBack_function = 0;    /* it will tell us if the callback function has ended or not */
uint8 volatile end_of_callBack_function2 =0;    /* it will tell us if the callback function 2 has ended or not */

extern uint8 duty_cycle;   // call the variable in the DC_motor.c file which
// carry the duty_cylcle wanted to be generated by the PWM

/*
 * Description:
 * function that initialize the PWM mode for timer0
 */
void PWM_Timer0_Start(uint8 duty_cycle){  /* send to it the duty cycle required */
	TCNT0 = 0;  // clear the counter register at the beginning
	OCR0 = duty_cycle;  // Setup the compare value based on the required input duty cycle

	// Setup the PWM mode with Non-Inverting
	// Setup the prescaler with F_CPU/8
	TCCR0 =  (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS00);

}

void stop_DC_Motor(){   /* callback function to stop the DC motor */
	DcMotor_Rotate(STOP,0);
	end_of_callBack_function = 1;   /* tell us that the callback function has been executed */
}

void stop_buzzer(){    /* callback function to stop the buzzer */
	Buzzer_off();   /* turn off the buzzer */
	end_of_callBack_function2 = 1;   /* tell us that the callback function has been executed */
}

int main(void){

	uint8 pass1[5];  /* array will carry the password entered for the first time */
	uint8 pass2[5];  /* array will carry the password entered for the second time */
	uint8 pass_to_open_door[5];  /* array will carry the password entered to open the door */
	uint8 pass_to_change_pass[5]; /* array will carry the password entered to change the password */

	uint8 password1_is_sent = 0;  /* tell us if the UART received the five numbers of the pass for the first time or not */
	uint8 password2_is_sent = 0;  /* tell us if the UART received the five numbers of the pass for the second time or not */
	uint8 key;  /* will store the number pressed from the keypad */
	uint8 passwrods_checked = 0;  /* tell us if the passwords have been checked or not */
	uint8 passwords_is_matched = 1; /* if the passwords do not match it will become 0 */
	uint8 from_uart1;               /* will store the values sent from the other UART */
	uint8 password_is_done = 0;     /* will indicate that we have stored the password in the EEPROM */
	UART_ConfigType uart_config = {bits_8, disabled, one_bit, 9600}; /* set the required configurations for the UART */
	UART_init(&uart_config); /* initiate the UART with the required configurations */
	TWI_ConfigType twi_config = {2,0b00010000};   /* set the required configurations for the TWI */
	TWI_init(&twi_config); /* initiate the TWI with the required configurations */
	DcMotor_Init(); /* initiate the DC motor */
	Timer1_setCallBack(stop_DC_Motor);   /* set the function (stop_DC_Motor) as the callback function for timer1 for the compare mode */
	Timer1_setCallBack2(stop_buzzer); /* set the function (stop_buzzer) as the callback function for timer1 for the NORMAL mode */
	Buzzer_init();  /* initiate the buzzer */

	while(1){

		if(!password_is_done){   /* if the passwords for the system have not been sent then do this instructions */
			if(!password1_is_sent){   /* if the password has not been sent then wait and receive it */
				for(uint8 i=0; i<5; i++){
					key = UART_recieveByte();   /* wait for the other UART to send the numbers of password */
					pass1[i] = key;    /* store the sent number in the array of the password */
				}
				password1_is_sent =1; /* tell that the password has been sent */
			}
			if(!password2_is_sent){  /* if the confirming password has not been sent then wait and receive it */
				for(uint8 i=0; i<5; i++){
					key = UART_recieveByte(); /* wait for the other UART to send the numbers of the confirming password */
					pass2[i] = key;   /* store the sent number in the array of the confirming password */
				}
				password2_is_sent =1;  /* tell that the confirming password has been sent */
			}
			if(!passwrods_checked){    /* if the two passwords have not been checked then compare them together */
				for(uint8 i=0; i<5; i++){
					if(pass1[i] != pass2[i]){
						passwords_is_matched = 0;  /* it will be set to 1 if any number does not equal the opposite to it */
					}
				}
				passwrods_checked =1;  /* inform that the passwords have been checked */
				if(passwords_is_matched){    /* if passwords is matched store the password in the EEPROM */
					password_is_done = 1;  /* tell that the phase of ensuring the passwords has ended */
					UART_sendByte(1);      /* tell the other UART that the two passwords are matched */
					EEPROM_writeByte(0x0311, pass1[0]); /* Write first character in the external EEPROM */
					_delay_ms(10);
					EEPROM_writeByte(0x0312, pass1[1]); /* Write second character in the external EEPROM */
					_delay_ms(10);
					EEPROM_writeByte(0x0313, pass1[2]); /* Write third character in the external EEPROM */
					_delay_ms(10);
					EEPROM_writeByte(0x0314, pass1[3]); /* Write fourth character in the external EEPROM */
					_delay_ms(10);
					EEPROM_writeByte(0x0315, pass1[4]); /* Write fifth character in the external EEPROM */
					_delay_ms(10);
				}
				else
				{   /* if the two passwords do not match send 0 to the other UART and reset every thing */
					UART_sendByte(0);
					password1_is_sent = 0;
					password2_is_sent = 0;
					passwrods_checked = 0;
					passwords_is_matched = 1;

				}
			}
		}

		if(password_is_done){  /* if the system has password then always wait for an order from the other UART */
			from_uart1 = UART_recieveByte();  /* the other UART will send a specific number and according to it
			                                     the system will do a specific job */
			if(from_uart1 == 2){ /* 2 means the system want to open the door */
				uint8 right_passwords = 0; /* will carry the number of the right numbers sent */
				for(uint8 i=0; i<5; i++){
					key = UART_recieveByte(); /* receive the five numbers sent from the other UART */
					pass_to_open_door[i] = key; /* store them in that array */
				}
				/* compare each number to the opposite to it and if right increment the right_passwords */
				uint8 val0 = 0;  /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0311, &val0);
				_delay_ms(10);
				if(pass_to_open_door[0] == val0){
					right_passwords++;
				}
				uint8 val1 = 0;  /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0312, &val1);
				_delay_ms(10);
				if(pass_to_open_door[1] == val1){
					right_passwords++;
				}
				uint8 val2 = 0; /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0313, &val2);
				_delay_ms(10);
				if(pass_to_open_door[2] == val2){
					right_passwords++;
				}
				uint8 val3 = 0; /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0314, &val3);
				_delay_ms(10);
				if(pass_to_open_door[3] == val3){
					right_passwords++;
				}
				uint8 val4 = 0; /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0315, &val4);
				_delay_ms(10);
				if(pass_to_open_door[4] == val4){
					right_passwords++;
				}
				UART_sendByte(right_passwords);   /* send the number of the right numbers to the other UART */
				uint8 motor_start = UART_recieveByte();  /* receive byte = 10 from the other UART to turn on the motor */
				if(right_passwords == 5 && motor_start ==  10){
					DcMotor_Rotate(CLOCK_WISE, 100); /* make the motor rotate clockwise and with full speed */
					PWM_Timer0_Start(duty_cycle); /* generate the PWM signal to rotate the motor */
					/* set the required configuration for timer1 to not stop the motor until it rotates the 15 seconds  */
					Timer1_ConfigType timer1_config= {0, 58600, F_CPU_1024, COMPARE_MODE};
					Timer1_init(&timer1_config); /* initiate time1 with the required configurations */
					while(!end_of_callBack_function); /* wait until timer1 interrupts and execute the callback
					                                     function and stop the motor */
					duty_cycle = 0;
					Timer1_deInit(); /* stop the timer1 */
					end_of_callBack_function = 0;  /* reset it to reuse it again */
					/* configure the time1 to count for 3 seconds while the DC motor is fixed */
					Timer1_ConfigType timer_config2= {0, 18000, F_CPU_1024, COMPARE_MODE};
					Timer1_init(&timer_config2);
					while(!end_of_callBack_function);
					Timer1_deInit();
					end_of_callBack_function = 0;
					/* rotate the motor anti clockwise with maximum speed for 15 seconds then stop it */
					DcMotor_Rotate(ANTI_CLOCK_WISE, 100);
					PWM_Timer0_Start(duty_cycle);
					Timer1_ConfigType timer_config3= {0, 58600, F_CPU_1024, COMPARE_MODE};
					Timer1_init(&timer_config3);
					while(!end_of_callBack_function);
					duty_cycle = 0;
					Timer1_deInit();
					end_of_callBack_function = 0;


				}
			}
			else if(from_uart1 == 3){  /* if the other UART sent 3 then the user want to change password */
				uint8 right_passwords = 0; /* will carry the number of the right numbers sent */
				for(uint8 i=0; i<5; i++){
					key = UART_recieveByte(); /* receive the five numbers sent from the other UART */
					pass_to_change_pass[i] = key; /* store them in that array */
				}
				/* compare each number to the opposite to it and if right increment the right_passwords */
				uint8 val0 = 0;  /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0311, &val0);
				_delay_ms(10);
				if(pass_to_change_pass[0] == val0){
					right_passwords++;
				}
				uint8 val1 = 0;  /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0312, &val1);
				_delay_ms(10);
				if(pass_to_change_pass[1] == val1){
					right_passwords++;
				}
				uint8 val2 = 0; /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0313, &val2);
				_delay_ms(10);
				if(pass_to_change_pass[2] == val2){
					right_passwords++;
				}
				uint8 val3 = 0; /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0314, &val3);
				_delay_ms(10);
				if(pass_to_change_pass[3] == val3){
					right_passwords++;
				}
				uint8 val4 = 0; /* value to read the stored value in the EEPROM */
				EEPROM_readByte(0x0315, &val4);
				_delay_ms(10);
				if(pass_to_change_pass[4] == val4){
					right_passwords++;
				}
				UART_sendByte(right_passwords);   /* send the number of the right numbers to the other UART */
				uint8 change_password = UART_recieveByte(); /* the other UART will send number 17 to tell the system to
				                                            allow changing the pass...17 is number from my choice */
				if(right_passwords == 5 && change_password == 17){ /* reset all things */
					password_is_done = 0;
					password1_is_sent = 0;
					password2_is_sent = 0;
					passwrods_checked = 0;
					passwords_is_matched = 1;
				}
			}
			else if(from_uart1 == 4){  /* 4 is number from my choice to tell the system that an error occurs and we want to
			                              turn on the buzzer for 1 minute */
				Buzzer_on(); /* turn on the buzzer */
				/* configure timer1 to overflow mode and use ticks to reach 7 times to count for 1 minute */
				Timer1_ConfigType timer1_config= {0, 0, F_CPU_1024, NORMAL_MODE};
				Timer1_init(&timer1_config); /* initiate timer1 with the required configurations */
				while(!end_of_callBack_function2); /* do not exit until timer1 execute the callbackfunction and  */
				Timer1_deInit();
				end_of_callBack_function2 = 0;


			}

		}
	}

}
